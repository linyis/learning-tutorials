# YouTube 影片摘要

**影片連結**: https://youtu.be/pvlPkUauHis?si=jiW6VbbBpX4hyvba

**影片 ID**: pvlPkUauHis

**處理日期**: 2026-02-10 09:08

**影片類型**: 教程/教學類影片

---

好的，以下是根据提供的转录文本生成的结构化笔记：

## 📌 影片主题
Opinclaw 的高级使用技巧与 Agent 运用，强调其作为 2026 年最强大的 AI agent 的潜力及未来发展方向。

## 📋 章節與時間戳
- 00:00 - 简介：Opinclaw 的定位与未来展望
- 02:30 - 模型容栽机制
- 08:00 - 多Agent 协同工作模式（三种模式）
- 16:00 - 记忆搜索功能
- 22:00 - 云端 Opinclaw 与本地 micro-s 系统连接
- 28:00 - 总结与技能分享

## 📖 內容重點
1. **Opinclaw 的定位：**
   -  被认为是 2026 年最强大的 AI agent
   -  未来将有更多基于 Opinclaw 的二次开发变体
   -  人人都有自己的 Opinclaw，实现指令自主完成工作

2. **模型容栽机制:**
   -  核心功能：防止主模型额度耗尽或被限制
   -  使用 GPT5.3c (valpax) 和谷歌antigravity (claw) 作为备用模型
   -  自动切换策略，确保 Opinclaw 始终可用

3. **多Agent 协同工作模式:**
    -  线性流水线模式：主Agent调度，Agent按任务产出结果（代码，测试，文档，审查）
    -  依赖图并行模式：根据任务依赖关系并行派发Agent
    -  多Agent 辩论模式：Agent 参与讨论并进行综合决策

4. **记忆搜索功能:**
    -  通过70次迭代将记忆搜索的配种路径和配置内容展示出来
    -  集成了jemania 模型和 science memory 实验性功能

5. **云端连接 micro-s 系统:**
    -  通过Node进行配对，实现ssh反向隧道
    -  可以远程操控本地micro-s系统，执行命令和图形界面操作

## 💡 實用技巧/命令
- **设置模型容栽机制:**
   -  在代码文件中配置容栽模型，确保 Opinclaw 即使主模型出现问题也能自动切换
   -  定义 valpax 列表，包含备用模型
- **多Agent 协同：**
    -  三种模式：线性流水线、依赖图并行、多Agent 辩论
    -  通过Skill安装，简化操作
- **云端连接 micro-s：**
    -  使用 Node 进行配对，通过 ssh 反向隧道实现远程访问
    -  利用命令启动 Agent，无需内网穿透

## 🔑 關鍵概念
- **AI Agent 终极形态:** Opinclaw 的定义和潜力
- **模型容栽机制:**  应对主模型额度问题，实现高可用性
- **多Agent 协作:**  并行处理任务，提高效率和灵活性
- **Node 配对 & ssh 反向隧道:**  实现云端和本地系统间的通信

---

希望这个结构化的笔记能够帮助你更好地理解和利用 Opinclaw。

---

## 📋 章節與時間戳

- [00:00] 本期视频继续为大家分享opinclaw的循用技巧还有使用经验
- [00:07] 并且还会为大家重点演示opinclaw中Agent的高级循用方式
- [00:12] 通过最近这段时间高强度的使用opinclaw我最大的感受就是opinclaw可以说是2026年最无力大的AI这种体
- [00:20] 而且在未来几个月还会有更多基于opinclaw二次开发的各种变体出现
- [00:26] 并且人人都会有自己的opinclaw甚至可以实现人类只需要给opinclaw下达指令一切工作都会有opinclaw自主完成
- [00:35] 因为最近几天所有的编程任务我都是直接下opinclaw下达指令然后由opinclaw完成所有的开发工作
- [00:43] 所以说opinclaw堪称AI agent的终极形态
- [00:47] 好下面为了也想显是opinclaw的使用经验还有使用技巧
- [00:51] 首先我们得设置一下opinclaw的模型容栽机制
- [00:55] 在这里我让opinclaw可以出当前模型容栽的配置代码还有文件路件
- [01:00] 然后这里就是opinclaw给出的模型容栽配置文件的路件
- [01:05] 然后我们可以详细看一下我这里是如何配置的模型容栽机制
- [01:09] 首先这里是配置的核心容栽
- [01:12] 这里我设置的主模型就是安爽pclaw的op4.6模型
- [01:17] 也就是这个模型只要它的额度没有耗件或者没有被限制
- [01:21] 那么在这个主 agent 中也就是当前对话的这个 agent 中
- [01:26] 它默认调用的模型就是我们设置了安爽pcclaw的op4.6模型
- [01:31] 假如使用的这个模型额度用光了或者是出现了问题或者是被限制了
- [01:37] 然后就可以从这个valpax列表中率先选择opinclaw的gpt5.3c model
- [01:44] 假设这个模型也不能用
- [01:46] 那么就会选择谷歌antigravity中的claw的op4.6新型模型
- [01:51] 所以做了这个模型容栽机制
- [01:54] 哪怕我们所使用的这个主模型它突然没有额度不能使用了
- [01:57] 那么在opinclaw中它也会自动切换到valpax列表里的这些模型
- [02:02] 像这样的话我们就能保证哪怕主模型出了问题
- [02:06] 然后我们的opinclaw也能正常地来使用
- [02:09] 而不会因为我们设置的主模型出现额度限制
- [02:12] 然后整个opinclaw都不能使用了情况
- [02:15] 所以说我设置了这个容栽机制它的执行流程就是
- [02:19] 当安索opica它的模型不能用了之后
- [02:21] 就会自动切换到opinclaw的claw
- [02:24] 如果opinclaw的claw
- [02:25] 还不能用的话那就自动切换到谷歌的antigravity
- [02:29] 想设置这个模型容栽机制非常简单
- [02:31] 我们只需要在这个代码文件中
- [02:33] 听家好我们作为容栽机制的其他模型就可以
- [02:37] 而且在这里我还实现了多人证还有token的轮换
- [02:40] 在这个配置文件中我登录了opinclaw的claw
- [02:44] 然后这个进行方式就是oos
- [02:46] 在这里我还登录了安索opica的账号
- [02:48] 在下面这里我还登录了两个antigravity的账号
- [02:52] 假设在使用antigravity的情况下
- [02:54] 比如说第一个antigravity的账号
- [02:56] 因为额度被限制了
- [02:58] 那么就会自动切换到第二个antigravity的账号
- [03:01] 相见的话我们就能实现antigravity两个账号的轮损
- [03:05] 而且在下面这里我还为我创建了这些adient分配了不同的模型
- [03:10] 像这个创建方式与分配方式
- [03:11] 我在上期视频也为大家演示了
- [03:14] 比如说这个主adient它使用的模型就是claw的opinclaw
- [03:17] 然后我还创建了因为文档编写了一只能给它分配的模型
- [03:21] 是antigravity的claw的三面四面五模型
- [03:25] 所以大家想自己设计的话
- [03:27] 只需要更改这个文件
- [03:28] 然后加入你所增加的这些模型
- [03:31] 然后也可以直接让opinclaw为你去新增这些融灾的这些模型
- [03:36] 下面再为大家讲解一下opinclaw中它的记忆搜索的功能
- [03:40] 在这里我直接用70次让它将记忆搜索的配种念路径
- [03:44] 还有配置的这些内容
- [03:46] 将它展示出来
- [03:47] 这个文件路径就在这个位置
- [03:49] 然后我们看一下我是如何设置opinclaw中它的记忆搜索的这个功能
- [03:54] 在这个配置文件中就可以看到它会兼索opinclaw
- [03:57] 它自带的记忆系统一及兼索science
- [04:00] 而且这里我开启了它的实验性功能
- [04:03] 也就是science memory
- [04:04] 将它设为了true
- [04:05] 在模型提供商这里我设置的是jemania
- [04:08] 在这里就是设置了jemania的epi key
- [04:11] 在它的模型ad这里
- [04:12] 我许用的就是jemania的ambending001这个模型
- [04:15] 在这里我之所以使用jemaniaambending001这个模型
- [04:19] 而没有选择用开源的QMD这个项目去实现记忆搜
- [04:24] 主要是因为QMD它需要下载gg.uf模型还需要实现长驻后台进程
- [04:29] 而且占用类吞还有cpu
- [04:31] 所以我选择了使用jemania的ambending模型
- [04:34] 像这样的话就能实现
- [04:36] 只需要设置一个epi key
- [04:38] 就可以实现混合做所
- [04:39] 从而让opinclaw越来越聪明
- [04:42] 下面我们再看一下第三个技巧
- [04:44] 第三个技巧就是用雲端的opinclaw
- [04:46] 来连接我本地的micro-s系统
- [04:49] 在这里并没有用到内网穿透等操作
- [04:52] 因为我使用的是雲端的opinclaw
- [04:54] 与本地的micro-s通过node的进行配对
- [04:58] 也就是在本地micro-s上通过ssh反向隧道
- [05:02] 连接到雲端的opinclaw
- [05:04] 然后我们可以看一下这个加固图
- [05:06] 首先雲端的opinclaw它就相当于一个真正的agent的蛋套
- [05:10] 它能通过录油工具来调用其他的这些node
- [05:14] 它通过websockin server来实现node的指令的非发
- [05:18] 它可以通过websockin的指令
- [05:21] 将指令通过node发送给micro-s
- [05:23] 来实现调用相机 实现屏幕阶途
- [05:26] 实现执行命令等操作
- [05:28] 在本地micro-s上它就是使用的ssh反向隧道
- [05:32] 出展连接
- [05:34] 因为它是主动出展
- [05:35] 所以不需要内网穿透
- [05:37] 也不需要端口硬设等这些负杂操作
- [05:40] 而且我们主要用命令来启动这个node就可以
- [05:43] 下面我们就可以看一下这个效果
- [05:45] 首先我们打开本地的中端mini-hung
- [05:47] 为确保它真的是通过node进行配对
- [05:50] 我们可以直接用这条命令
- [05:52] 直接将本地的getaway彻底关掉
- [05:54] 我们直接执行这条命令
- [05:56] 这里就将我本地的getaway彻底关掉了
- [05:58] 然后下面我们主要在mini-hung中
- [06:00] 而启动node就行
- [06:02] 我这里将其中方式做成了快节命令
- [06:04] 我只需要输入a.json
- [06:06] 然后就可以启动我们直接启动
- [06:08] 这里其实正在建立ssh随道
- [06:10] 然后我们就可以回到opin-clown
- [06:12] 然后给它下达一个任务
- [06:14] 让它从云端来操控我本地的micro-s系统
- [06:18] 再输入判我们可以先输入一个指令
- [06:20] 我输了是检查本地micro-s
- [06:22] 和你是否建立了连接
- [06:24] 然后我们看一下它输出的状态是怎样的
- [06:27] 在这里它很快输出了状态
- [06:29] 在这里就是我的micro-s
- [06:31] 连接状态就是在线
- [06:32] 所以具备的能力就是榴栏器雕用
- [06:35] 灯灯能力
- [06:35] 在这里就是micro-s随道
- [06:38] 正常明先可以知心远程命令
- [06:40] 在这里我们就可以给它下达一个任务
- [06:42] 我输的任务就是通过micro-s上的cloud-code
- [06:45] 雕用榴栏器发一篇xpost
- [06:47] 内容就是你对opin-clown未来发展的预测
- [06:50] 然后我们直接发送
- [06:51] 看一下它能否通过云端
- [06:53] 雕用我本地micro-s上的cloud-code
- [06:56] 在通过cloud-code
- [06:57] 雕用榴栏器实现发布xpost
- [07:01] 它自动打开了
- [07:03] 我本地的micro-s上的榴栏器
- [07:08] 它自动打开x并且自动
- [07:12] 输入了要发布的内容
- [07:17] 它这里发布成功
- [07:19] 然后这里其实发布成功
- [07:21] 这样的话我们就实现了让云端的opin-clown通过node
- [07:24] 超过我们本地的cloud-code
- [07:26] 实现榴栏器雕用
- [07:27] 下面我们就可以输出70次
- [07:29] 将云端opin-clown
- [07:30] 于本地micro-s通过node的配对的步骤
- [07:33] 写春笔记
- [07:34] 这样的话大家就可以将笔记发给
- [07:37] 自己的opin-clown
- [07:37] 让自己的opin-clown
- [07:39] 根据笔记来实现配对
- [07:41] 在这里觉得它可以输得笔记
- [07:42] 像这些笔记我会放在我的播客中
- [07:44] 大家可以从我的播客去查找
- [07:46] 下面机会的也讲解opin-clown中
- [07:48] Agent的更多使用方式
- [07:50] 在这里我创建了4个Agent 并且放入了4个群组
- [07:54] 我创建了这4个Agent 它们的作用就是
- [07:57] 一个开发团队的想像
- [07:59] 这4个Agent 就相当于4大专职的AI成员
- [08:03] 其中这一个Agent 是负责携带码的
- [08:05] 这个Agent 负责进行测试
- [08:07] 然后这个是负责围囊维护
- [08:09] 还有这个是监控这些运行状态的
- [08:12] 我创建了这4个Agent 它们的运行方式
- [08:15] 跟之前视频里为大家演示的是不一样的
- [08:18] 目前我创建了这4个Agent 它完全是有主Agent 进行调度
- [08:22] 而且具备三种鞋作模式
- [08:25] 第一种鞋作模式就是现性流水线鞋作模式
- [08:28] 也就是有主Agent 作为调度中心
- [08:31] 它作为组织会
- [08:32] 它会根据我们下达的任务
- [08:34] 将任务为Paggy 下面的这4个Agent 它
- [08:36] 最后就会根据我们下达的开发任务
- [08:39] 产出最终的成品
- [08:40] 包括带码 围囊等内容
- [08:43] 它支持第二种鞋作模式
- [08:45] 也就是依赖图并行鞋作模式
- [08:47] 首先可以根据任务来声明依赖关系
- [08:50] 依赖满足之后就会并行派发多个Agent 它
- [08:53] 比如说有主Agent 进行调度
- [08:56] 可以同时调度用于围囊维护的Agent
- [08:59] 还有带码编写的Agent 然后再并行调用
- [09:02] 这两个Agent 最后再并行调用
- [09:04] 运行测试的还要编写围囊的
- [09:06] 最后可以出最终的审查还有交付
- [09:09] 相见的话我们就实现了一个更加灵活的Agent 鞋作工作流
- [09:13] 然后我还实现了第三种鞋作模式
- [09:16] 也就是多Agent 辩论
- [09:17] 我是受Cloud Code 的Agent 体面词的启发
- [09:20] 来实现了
- [09:21] 相见的话我们就可以在OpenCloud中
- [09:24] 实现让我们创建了Agent 进行多阶段的辩论
- [09:27] 首先我们只需要提出一个辩论的问题
- [09:30] 然后又准Agent 进行调度
- [09:33] 然后创建这些控制文件
- [09:34] 然后就进入了第一轮的辩论
- [09:36] 主Agent 就会派发任务给这三个Agent
- [09:39] 然后这三个Agent 辩论结果
- [09:41] 再由主Agent 收集
- [09:43] 然后再进入第二轮的辩论
- [09:45] 再由主Agent 来生成这些任务
- [09:48] 再围派给这三个Agent 到这一个阶段
- [09:51] 就会进行综合决策
- [09:53] 这些辩论内容就会会总给主Agent 进行综合决策
- [09:57] 最后给出最终的建议
- [09:59] 相见的话我们就能真正发挥出OpenCloud
- [10:02] 它的多Agent 它的优势
- [10:04] 下面我们就可以测试一下这三种鞋座模式中的
- [10:07] 第一种
- [10:08] 然后我们只需要在主Agent 中
- [10:11] 输入70词就可以
- [10:13] 我这里输入了70词试
- [10:14] 让它使用Tim Task 线性模式开发一个Piesing 搅本
- [10:18] 功能就是抓取这个网站的前10条线围
- [10:21] 然后我们直接发送
- [10:23] 看一下这个效果
- [10:24] 好 这里70这个任务已经完成
- [10:26] 当任务完成之后
- [10:27] 我们就可以看到这四个云足里
- [10:30] 这些Agent 非别输出了自己所完成的这些任务
- [10:33] 第一个阶段就是由编写代码的Agent 还编写代码
- [10:37] 第二个就是由测试的Agent 进行测试
- [10:39] 包括11个测试全部通过98%改率
- [10:43] 第三个论就是文档编写的Agent 来编写这个Ridamy文档
- [10:47] 包含安装使用方式的
- [10:49] 最后就是由这个审查Agent 进行质量拼分
- [10:52] 拼分结果就是生产级的代码
- [10:54] 然后它把我们实现的这个代码就保存在了这个位置
- [10:57] 这里还给出了运行方式
- [10:59] 相见的话我们就实现了这个多Agent 场场景中
- [11:02] 现性流水线了这个协作模式
- [11:04] 由于实现有限剩下了这两个场景就不在为的压侧式了
- [11:08] 我已经把它做成了Skill
- [11:10] 然后大家只需要将这个Skill安装到自己的Open Cloud
- [11:14] 然后就可以在Open Cloud 中使用这三种模式
- [11:17] 进行下午开发
- [11:18] 视频中用到的代码和笔记
- [11:20] 我都会放在视频下方的描述栏或者评论区
- [11:23] 如果你在视频下方无法找到的话
- [11:25] 也可以通过我的BOK去查到本期视频所对应的笔记
- [11:29] 把本期视频中做到这里
- [11:31] 欢迎大家点赞关注和转发
- [11:33] 谢谢大家观看

---

## 📖 完整轉錄內容

本期视频继续为大家分享opinclaw的循用技巧还有使用经验并且还会为大家重点演示opinclaw中Agent的高级循用方式通过最近这段时间高强度的使用opinclaw我最大的感受就是opinclaw可以说是2026年最无力大的AI这种体而且在未来几个月还会有更多基于opinclaw二次开发的各种变体出现并且人人都会有自己的opinclaw甚至可以实现人类只需要给opinclaw下达指令一切工作都会有opinclaw自主完成因为最近几天所有的编程任务我都是直接下opinclaw下达指令然后由opinclaw完成所有的开发工作所以说opinclaw堪称AI agent的终极形态好下面为了也想显是opinclaw的使用经验还有使用技巧首先我们得设置一下opinclaw的模型容栽机制在这里我让opinclaw可以出当前模型容栽的配置代码还有文件路件然后这里就是opinclaw给出的模型容栽配置文件的路件然后我们可以详细看一下我这里是如何配置的模型容栽机制首先这里是配置的核心容栽这里我设置的主模型就是安爽pclaw的op4.6模型也就是这个模型只要它的额度没有耗件或者没有被限制那么在这个主 agent 中也就是当前对话的这个 agent 中它默认调用的模型就是我们设置了安爽pcclaw的op4.6模型假如使用的这个模型额度用光了或者是出现了问题或者是被限制了然后就可以从这个valpax列表中率先选择opinclaw的gpt5.3c model假设这个模型也不能用那么就会选择谷歌antigravity中的claw的op4.6新型模型所以做了这个模型容栽机制哪怕我们所使用的这个主模型它突然没有额度不能使用了那么在opinclaw中它也会自动切换到valpax列表里的这些模型像这样的话我们就能保证哪怕主模型出了问题然后我们的opinclaw也能正常地来使用而不会因为我们设置的主模型出现额度限制然后整个opinclaw都不能使用了情况所以说我设置了这个容栽机制它的执行流程就是当安索opica它的模型不能用了之后就会自动切换到opinclaw的claw如果opinclaw的claw还不能用的话那就自动切换到谷歌的antigravity想设置这个模型容栽机制非常简单我们只需要在这个代码文件中听家好我们作为容栽机制的其他模型就可以而且在这里我还实现了多人证还有token的轮换在这个配置文件中我登录了opinclaw的claw然后这个进行方式就是oos在这里我还登录了安索opica的账号在下面这里我还登录了两个antigravity的账号假设在使用antigravity的情况下比如说第一个antigravity的账号因为额度被限制了那么就会自动切换到第二个antigravity的账号相见的话我们就能实现antigravity两个账号的轮损而且在下面这里我还为我创建了这些adient分配了不同的模型像这个创建方式与分配方式我在上期视频也为大家演示了比如说这个主adient它使用的模型就是claw的opinclaw然后我还创建了因为文档编写了一只能给它分配的模型是antigravity的claw的三面四面五模型所以大家想自己设计的话只需要更改这个文件然后加入你所增加的这些模型然后也可以直接让opinclaw为你去新增这些融灾的这些模型下面再为大家讲解一下opinclaw中它的记忆搜索的功能在这里我直接用70次让它将记忆搜索的配种念路径还有配置的这些内容将它展示出来这个文件路径就在这个位置然后我们看一下我是如何设置opinclaw中它的记忆搜索的这个功能在这个配置文件中就可以看到它会兼索opinclaw它自带的记忆系统一及兼索science而且这里我开启了它的实验性功能也就是science memory将它设为了true在模型提供商这里我设置的是jemania在这里就是设置了jemania的epi key在它的模型ad这里我许用的就是jemania的ambending001这个模型在这里我之所以使用jemaniaambending001这个模型而没有选择用开源的QMD这个项目去实现记忆搜主要是因为QMD它需要下载gg.uf模型还需要实现长驻后台进程而且占用类吞还有cpu所以我选择了使用jemania的ambending模型像这样的话就能实现只需要设置一个epi key就可以实现混合做所从而让opinclaw越来越聪明下面我们再看一下第三个技巧第三个技巧就是用雲端的opinclaw来连接我本地的micro-s系统在这里并没有用到内网穿透等操作因为我使用的是雲端的opinclaw与本地的micro-s通过node的进行配对也就是在本地micro-s上通过ssh反向隧道连接到雲端的opinclaw然后我们可以看一下这个加固图首先雲端的opinclaw它就相当于一个真正的agent的蛋套它能通过录油工具来调用其他的这些node它通过websockin server来实现node的指令的非发它可以通过websockin的指令将指令通过node发送给micro-s来实现调用相机 实现屏幕阶途实现执行命令等操作在本地micro-s上它就是使用的ssh反向隧道出展连接因为它是主动出展所以不需要内网穿透也不需要端口硬设等这些负杂操作而且我们主要用命令来启动这个node就可以下面我们就可以看一下这个效果首先我们打开本地的中端mini-hung为确保它真的是通过node进行配对我们可以直接用这条命令直接将本地的getaway彻底关掉我们直接执行这条命令这里就将我本地的getaway彻底关掉了然后下面我们主要在mini-hung中而启动node就行我这里将其中方式做成了快节命令我只需要输入a.json然后就可以启动我们直接启动这里其实正在建立ssh随道然后我们就可以回到opin-clown然后给它下达一个任务让它从云端来操控我本地的micro-s系统再输入判我们可以先输入一个指令我输了是检查本地micro-s和你是否建立了连接然后我们看一下它输出的状态是怎样的在这里它很快输出了状态在这里就是我的micro-s连接状态就是在线所以具备的能力就是榴栏器雕用灯灯能力在这里就是micro-s随道正常明先可以知心远程命令在这里我们就可以给它下达一个任务我输的任务就是通过micro-s上的cloud-code雕用榴栏器发一篇xpost内容就是你对opin-clown未来发展的预测然后我们直接发送看一下它能否通过云端雕用我本地micro-s上的cloud-code在通过cloud-code雕用榴栏器实现发布xpost它自动打开了我本地的micro-s上的榴栏器它自动打开x并且自动输入了要发布的内容它这里发布成功然后这里其实发布成功这样的话我们就实现了让云端的opin-clown通过node超过我们本地的cloud-code实现榴栏器雕用下面我们就可以输出70次将云端opin-clown于本地micro-s通过node的配对的步骤写春笔记这样的话大家就可以将笔记发给自己的opin-clown让自己的opin-clown根据笔记来实现配对在这里觉得它可以输得笔记像这些笔记我会放在我的播客中大家可以从我的播客去查找下面机会的也讲解opin-clown中Agent的更多使用方式在这里我创建了4个Agent 并且放入了4个群组我创建了这4个Agent 它们的作用就是一个开发团队的想像这4个Agent 就相当于4大专职的AI成员其中这一个Agent 是负责携带码的这个Agent 负责进行测试然后这个是负责围囊维护还有这个是监控这些运行状态的我创建了这4个Agent 它们的运行方式跟之前视频里为大家演示的是不一样的目前我创建了这4个Agent 它完全是有主Agent 进行调度而且具备三种鞋作模式第一种鞋作模式就是现性流水线鞋作模式也就是有主Agent 作为调度中心它作为组织会它会根据我们下达的任务将任务为Paggy 下面的这4个Agent 它最后就会根据我们下达的开发任务产出最终的成品包括带码 围囊等内容它支持第二种鞋作模式也就是依赖图并行鞋作模式首先可以根据任务来声明依赖关系依赖满足之后就会并行派发多个Agent 它比如说有主Agent 进行调度可以同时调度用于围囊维护的Agent还有带码编写的Agent 然后再并行调用这两个Agent 最后再并行调用运行测试的还要编写围囊的最后可以出最终的审查还有交付相见的话我们就实现了一个更加灵活的Agent 鞋作工作流然后我还实现了第三种鞋作模式也就是多Agent 辩论我是受Cloud Code 的Agent 体面词的启发来实现了相见的话我们就可以在OpenCloud中实现让我们创建了Agent 进行多阶段的辩论首先我们只需要提出一个辩论的问题然后又准Agent 进行调度然后创建这些控制文件然后就进入了第一轮的辩论主Agent 就会派发任务给这三个Agent然后这三个Agent 辩论结果再由主Agent 收集然后再进入第二轮的辩论再由主Agent 来生成这些任务再围派给这三个Agent 到这一个阶段就会进行综合决策这些辩论内容就会会总给主Agent 进行综合决策最后给出最终的建议相见的话我们就能真正发挥出OpenCloud它的多Agent 它的优势下面我们就可以测试一下这三种鞋座模式中的第一种然后我们只需要在主Agent 中输入70词就可以我这里输入了70词试让它使用Tim Task 线性模式开发一个Piesing 搅本功能就是抓取这个网站的前10条线围然后我们直接发送看一下这个效果好 这里70这个任务已经完成当任务完成之后我们就可以看到这四个云足里这些Agent 非别输出了自己所完成的这些任务第一个阶段就是由编写代码的Agent 还编写代码第二个就是由测试的Agent 进行测试包括11个测试全部通过98%改率第三个论就是文档编写的Agent 来编写这个Ridamy文档包含安装使用方式的最后就是由这个审查Agent 进行质量拼分拼分结果就是生产级的代码然后它把我们实现的这个代码就保存在了这个位置这里还给出了运行方式相见的话我们就实现了这个多Agent 场场景中现性流水线了这个协作模式由于实现有限剩下了这两个场景就不在为的压侧式了我已经把它做成了Skill然后大家只需要将这个Skill安装到自己的Open Cloud然后就可以在Open Cloud 中使用这三种模式进行下午开发视频中用到的代码和笔记我都会放在视频下方的描述栏或者评论区如果你在视频下方无法找到的话也可以通过我的BOK去查到本期视频所对应的笔记把本期视频中做到这里欢迎大家点赞关注和转发谢谢大家观看

---

*由 OpenClaw youtube-summary 生成*
