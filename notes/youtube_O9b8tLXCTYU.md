# YouTube 影片摘要

- **影片連結**: https://youtu.be/O9b8tLXCTYU?si=izWCbuqUO63FeM-D
- **處理時間**: 2026-02-07 19:49
- **內容來源**: Whisper 轉錄
- **分析模型**: ollama

## AI 分析結果

好的，我来分析一下这段视频内容，并整理成Markdown格式：

## 影片分析：解构智能体概念与未来趋势

**1. 影片主要主题：**

影片主要探讨了当前流行的“智能体”（Agent）概念的来龙去脉，剖析了其背后的技术原理和演变过程，并对未来发展趋势进行了预测。视频旨在揭示这些看似高科技的概念，其实是基于大语言模型（LLM）的各种技术堆砌，并指出了它们潜在的局限性和未来发展方向。

**2. 关键要点：**

*   **LLM的诞生：** LLM 起初是简单的文字接龙模型，参数增大后出现“智能”迹象。
*   **Prompt 的重要性：** 通过人为角色区分和 Prompt 设计，可以对 LLM 进行初步的控制和利用。
*   **Context 的作用：** Context（上下文）允许 LLM 模拟对话，存储和追问信息。
*   **Memory 的引入：** 通过 Memory 机制压缩 LLM 的 Context，提高效率。
*   **Agent 的出现：** Agent 引入程序代理 LLM 进行搜索和工具操作，提升能力。
*   **RIG (Retrieval Augmented Generation)：** 通过检索增强生成，提高 LLM 回答的可靠性。
*   **Function Calling & MCP (Model Context Protocol)：** 规范 LLM 和工具/程序之间的交互，简化开发流程。
*   **Skew：** 作为 Prompt 加载器，简化流程，兼顾灵活性和稳定性。
*   **Workflow & Lanchet：** Workflow 提供低代码流程编排，Lanchet 提供纯编程方式实现自动化。
*   **未来趋势：**
    *   Token 成本降低，将推动 Agent 更广泛应用。
    *   产品会更注重用户便利性，简化配置和操作流程。
    *   未来会出现打包好的、无需复杂配置的超级 Agent。

**3. 实用建议或结论：**

*   **理解核心：** 这些看似复杂的“智能体”概念，本质上是围绕 LLM 的技术堆叠，理解其底层原理有助于更好地应用它们。
*   **关注便利性：** 未来 Agent 的发展方向是更易用、更便捷，简化操作流程。
*   **Token 成本：** 关注 Token 成本的变化，这将直接影响 Agent 的应用范围。
*   **核心价值是效率：** 所有技术方案的目标是提高效率，减少人力成本。
*   **不要过度迷信新概念：**  新概念出现时，需理性看待，避免被营销炒作迷惑。

**4. 需要深入了解的延伸话题：**

*   **大模型背后的架构：** 了解 Transformer 架构和 LLM 的训练方法。
*   **Prompt Engineering：** 深入研究 Prompt 设计技巧，优化 LLM 的输出结果。
*   **Vector Database (向量数据库):** 掌握向量数据库的工作原理及应用，用于检索增强生成 (RIG)。
*   **Function Calling 的实现细节：** 理解 Function Calling 如何规范 LLM 和工具/程序之间的交互。
*   **LangChain & Workflow 的实践：** 学习如何使用这些框架构建 Agent 应用。
*   **CloudBot / Multibot / OpenCloud 的设计与实现：**  了解这些 Agent 的具体实现原理，分析其成功因素。
*   **Token 成本的影响因素：**  深入研究 Token 成本的构成，以及降低 Token 成本的方法。
*   **智能体安全问题：** 探讨如何保证智能体的安全性和可靠性，防止其被恶意利用。



希望这个分析对您有所帮助！


## 轉錄內容時間戳

- [00:00] 这几个词你认识多少
- [00:01] 这几个词你认识多少
- [00:02] 这几个词你又认识多少
- [00:04] 如果你全都不认识
- [00:06] 那么恭喜你来队的地方
- [00:07] 今天这期视频
- [00:08] 我就为你拔开所有这些虎人概念的底库
- [00:11] 你会发现
- [00:11] 所谓智能体就是所有不需要智能的部分
- [00:14] 构成的部分
- [00:15] SKILL就是新评装救久的一场名词诈骗
- [00:17] 最后我还会告诉你个
- [00:19] 通杀现在所有甚至未来可能出现的
- [00:22] 新概念的统一方法论
- [00:23] 让你瞬间瞄懂
- [00:24] 这好像是个语病
- [00:26] 但这不重要
- [00:27] 现在你只需要亲空大脑
- [00:28] 忘掉你所有知道和不知道的概念
- [00:30] 跟我一起进入梦境
- [00:34] 整个混乱的起点就是这个古老的语言模型
- [00:37] 小的语言模型一开始还是个制造
- [00:39] 但随着模型的参数越来越大
- [00:41] 居然在某个邻界点有限出了智能
- [00:43] 为了和之前这个制造模型做个区分
- [00:45] 你在前面加了个大字
- [00:47] 这就构成了现在常说的大语言模型
- [00:49] 简称LLM
- [00:51] 恭喜你发明了今天的第一个新词
- [00:53] 大模型本身只能做文字接龙
- [00:55] 就是不断输出下一个字
- [00:57] 如果只是这么用的话
- [00:58] 看起来仍然像个智障
- [01:00] 如果把角色区分一下
- [01:01] 人为划分成一问一答两个角色
- [01:04] 就实现了第一个有点智能的使用方式
- [01:06] 对话
- [01:07] 现在我不管你是什么身份
- [01:09] 立刻把自己想成一个老板
- [01:10] LLM就是你的员工
- [01:12] 我们就叫他小L吧
- [01:13] 只不过他服务你的方式有点特别
- [01:15] 只能一问一答
- [01:16] 然后就结束了
- [01:17] 不能追问
- [01:18] 不能追问
- [01:19] 不能追问
- [01:20] 这个非常重要
- [01:21] 后面有考
- [01:22] 接下来的任务就是
- [01:23] 你要想尽办法压榨这个
- [01:25] 只会一问一答的小L
- [01:26] 榨干他的全部胜利价值
- [01:28] 那你会怎么做呢
- [01:29] 不过先别急
- [01:30] 你先给自己每次和小L的对话
- [01:33] 起了个洋气的名字
- [01:34] 叫prompt
- [01:34] 恭喜你发明了今天的第二个词
- [01:36] 然后你还发现这部分内容
- [01:38] 还可以进一步区分
- [01:39] 有的部分是背景信息
- [01:40] 有的部分是最终的指示
- [01:42] 于是你把背景信息的部分单独起了个名
- [01:45] 叫contax
- [01:45] 上下文
- [01:46] 那恭喜你发明了今天第三个词
- [01:48] 同时有的时候
- [01:49] 你需要对小L进行追问
- [01:51] 但是刚刚说了
- [01:52] 他只能一问一答不能追问
- [01:54] 但是你想了个巧妙的办法
- [01:56] 就是每次沟通前
- [01:57] 把你们之前的对话历史放到contax部分
- [02:00] 作为上下文信息
- [02:01] 然后再给出你的问题
- [02:02] 伪装成多人对话
- [02:04] 然后你又迫不及待
- [02:05] 给这些特殊的上下文信息起了个新词
- [02:07] 叫memory
- [02:08] 意思是大模型的记忆
- [02:09] 这些memory还可以再次调用大模型
- [02:11] 进行总结
- [02:12] 从而对它的记忆进行压缩
- [02:14] 进而减少上下文的长度
- [02:15] 恭喜你
- [02:16] 一不小心就已经发明了四个新词了
- [02:19] 此时
- [02:19] 一个原本只能进行词语节轮的小L
- [02:22] 就成功被你玩出了可以对话
- [02:24] 并且可以不断追问的优秀牛马员工了
- [02:27] 当然
- [02:27] 不久之后你就不满足一现状了
- [02:29] 你发现的第一个问题就是
- [02:31] 小L没有上网查阅资料的能力
- [02:33] 要么就不知道
- [02:34] 要么就胡说八道
- [02:35] 说的内容都是些过时的消息
- [02:37] 不过这很简单
- [02:38] 给小L准备一台电脑不就可以了
- [02:40] 不可以
- [02:41] 还是那个问题
- [02:42] 小L本身只会资予巨龙
- [02:44] 其他任何逻辑都无法独立完成
- [02:46] 那怎么办呢
- [02:47] 好吧
- [02:48] 你就告诉小L
- [02:49] 如果你需要上网搜索资料的话
- [02:51] 就告诉你
- [02:51] 然后你帮忙查完资料后再给它
- [02:53] 不就行了
- [02:54] 但很快你就发现
- [02:55] 这样好像显得自己有点蠢
- [02:57] 到底谁才是牛马
- [02:58] 于是你把上网这部分逻辑写成了一段程序
- [03:01] 让这个程序去代理你和小L进行沟通
- [03:04] 并且完成搜索的任务
- [03:05] 在外人看来
- [03:06] 你仍然是一问一答就拿到了结果
- [03:08] 只不过面向的是这个神秘的程序了
- [03:11] 太妙了
- [03:12] 这个发明可不得了
- [03:13] 这个神秘的程序
- [03:14] 似乎本身就拥有了智能
- [03:15] 而且还是能操作工具的
- [03:17] 更高级别的智能
- [03:18] 你给它取名叫
- [03:19] 智能体Agent
- [03:20] 你可能觉得写作战程序不是看起来很简单吗
- [03:23] 怎么敢叫这么科幻的名字
- [03:25] 千万别有心理负担
- [03:26] 一些早期所谓的智能体
- [03:28] 其实线逻辑仅仅就是多加了一段prompt而已
- [03:31] 从现在的视角回看
- [03:32] 当之简直就是一种诈骗
- [03:35] 回到这里
- [03:35] 既然这个Agent能上网搜索内容了
- [03:38] 那是不是也可以增加个搜索本地文档或数据库的能力呢
- [03:41] 可以的
- [03:42] 只不过搜索方式和传统数据库不同
- [03:44] 要使用相量数据库
- [03:45] 把语意相近的片段找出来
- [03:48] 你给这种通过语意匹配相量化的信息
- [03:50] 并将其加入商项文以增强生成内容的可靠性办法
- [03:54] 叫做解锁增强生成
- [03:56] retrieval augmented generation 简称RIG
- [03:58] 抱歉
- [03:59] 有股东北大茶的味
- [04:01] 刚刚这个联网搜索也写个名字
- [04:03] 叫web-search
- [04:04] 算了
- [04:05] drop the web
- [04:06] just search
- [04:07] 这样Score分显得更大一些
- [04:09] 连RIG也算是search的一种了
- [04:11] 都属于获取模型参数以外的信息的能力
- [04:14] 好了
- [04:15] 现在看看你造的孽吧
- [04:16] 这么一会功夫已经发明了8个新词了
- [04:19] 当然
- [04:19] 好戏还在后头呢
- [04:21] 好了
- [04:22] 现在的整体架构就是
- [04:23] 你和小L中间隔着一层A字的程序
- [04:26] 用于减少你和大模型直接沟通的四处
- [04:28] 并且处理一些小L无法操作的东西
- [04:30] 包括刚刚的搜索
- [04:32] 以及还可能出现的其他各种工具的调用
- [04:34] 但这就有个问题
- [04:35] 我们聚焦于A字和大模型的对话过上来看
- [04:38] 如果这部分一直用自然语言来沟通
- [04:41] 那这个A字的代码可不好用程序来实现
- [04:43] 鬼知道大模型会怎么描述自己的需求呢
- [04:46] 所以最好有个约定
- [04:47] 让大模型按照指定的死板的格式来回复
- [04:50] 比如说Jason
- [04:51] 这样程序就能直接很方便的解析了
- [04:54] 你给这种A字和大模型之间
- [04:56] 关于工具调用所约定的对话格式
- [04:58] 叫做function calling
- [04:59] 其实就是个约定吧
- [05:01] 就好像开发的时候前端和后端约定接口格式一样
- [05:05] 好了
- [05:05] 我们再看看右边
- [05:07] 这些工具的实现现在是写在A字的主程序里面的
- [05:10] 没有跟核心功能解有
- [05:11] 如果是单独写成一个服务
- [05:13] 那么A字的主程序如何发现并调用这个服务
- [05:16] 就又需要一套约定的规范了
- [05:18] 比如说约定好Toros List的方法
- [05:20] 就是返回工具列表
- [05:22] Toros Call方法就是调用具体的工具等等
- [05:25] 也就是一套约定而已
- [05:26] 那你给这边的约定也起了个名字
- [05:28] 叫做MCP
- [05:29] 翻译过来叫模型上下文协议
- [05:32] 至此
- [05:32] 架构就变成了这个样子
- [05:34] 此时大模型就像个只会说话不会做的智者
- [05:37] 而MCP服务就是能提供各种工具的程序级
- [05:41] 中间的A字就是个传话筒
- [05:43] 把弹模型的话转换成调用工具的代码
- [05:45] 把工具调的结果在原封不动的传话给大模型
- [05:49] 同时别忘了还要给你这个老板传话
- [05:51] 主打一个我不生产信息
- [05:53] 我只是信息的班运工
- [05:55] 现在我们聚焦于A字和你的对话之间
- [05:58] 虽然最底层肯定还是文字
- [06:00] 但是交互形式上可以非常丰富多彩
- [06:03] 可以是像CRI一样的迷你行窗口
- [06:05] 也可以是一个编程ID工具
- [06:07] 还可以是一个更为通用的桌面助手
- [06:09] 比如说最近爆火的CloudBot,Multibot,OpenCloud
- [06:12] 当然这三是一个东西
- [06:14] 这里说句题外话
- [06:15] 我感觉Cloud Code这个名字起的实在太失败了
- [06:18] 一开始好多人认为它是个大模型的名字
- [06:21] 但其实它是个编程Agent
- [06:23] 现在好不容易大家接受它是个编程Agent了
- [06:25] 但其实它早就走上了通用Agent的道路
- [06:28] 我感觉要是名字写好了就没现在的CloudBot什么事了
- [06:31] 当然CloudBot的爆火和它的自身的很多设计有关
- [06:35] 如果本期视频的点赞过意
- [06:37] 我将会专门出一期视频讲讲它
- [06:39] 不过不论什么形式的智能体都有一个统一的缺点
- [06:42] 假设我们想完成这样一个任务
- [06:44] 从一个英文PDF文档当中提取内容翻译成中文
- [06:47] 最后保存成MarkTang格式
- [06:49] 大家你可以直接把这个需求描述给Agent
- [06:51] 让它自己策划整体的流程
- [06:53] 但如果这个流程相对稳定
- [06:55] 每次重新让Agent的自由发挥的话
- [06:57] 不但不稳定还非常浪费偷肯
- [07:00] 比如说整个流程中提取PDF和保存MarkTang这两步
- [07:03] 完全可以固化成固定的脚本
- [07:06] 中间的翻译直接和大模型沟通即可
- [07:08] 整个流程就不需要任何一个中间的智能体插手了
- [07:11] 要固化这样一个流程
- [07:12] 你可以通过编程的方式来实现
- [07:15] 为了方便编写这种练识的任务
- [07:17] 你又发明了一个新的编程框架
- [07:18] 起码叫Lanchain
- [07:20] 为了照顾非一成学员用户
- [07:21] 你又发明了一种低代码的方式
- [07:23] 就是在页面上傻瓜式的拖拽
- [07:25] 上手难度更低
- [07:27] 你给它起了名字叫WalkFlow及工作流
- [07:30] 但是还有个问题
- [07:31] 假如这个问题我们再变一下
- [07:33] 比如说处理原始文档不只有PDF
- [07:35] 还有可能是Word文档
- [07:36] TXT文档
- [07:37] PBT等
- [07:38] 然后输出的格式也可能是HTML
- [07:41] PDF甚至是一张图片
- [07:42] 那么难道你要给这些所有的排列口盒
- [07:45] 都写一套工作流吗
- [07:46] 这显然是不合适的
- [07:48] 当然了
- [07:48] 你也可以写一堆EVE ALS做判断
- [07:51] 但是如果你仍然希望用户
- [07:52] 是以自然语的方式出发这个任务
- [07:54] 不牺牲这个体验
- [07:55] 这个时候就又不好用程序来判断分支了
- [07:58] 那该怎么办呢
- [07:59] 你可以这样设计
- [08:00] 准备一个目录
- [08:01] 把所有可能设计到的转换脚本
- [08:04] 全都写好放在这
- [08:05] 然后写个统一的双用文件
- [08:07] 把整体的流程描述清楚
- [08:09] 并且告诉Agent根据文件的格式
- [08:11] 灵活选取指定的脚本
- [08:13] 然后再给Agent的下达任务之前
- [08:15] 加上这么一句话
- [08:16] 先读取刚刚我们写好的那一大串要求
- [08:19] 然后再按照要求完成任务
- [08:21] 这样整个过程就既保证了一定的灵活性
- [08:23] 同时又变得比较可控
- [08:25] 但是这不就又来了优化空间吗
- [08:27] 我可以提前约定好某个指定的位置
- [08:30] 然后在Agent中写死一段程序
- [08:33] 去读取这个位置的Skew.MD
- [08:35] 还是想到于把这句话固化成了一段程序
- [08:38] 这样就不用每次都加这么一句废话了
- [08:41] 虽然你也知道这破版上好像就是把提示词换了个地方存起来
- [08:44] 但想想还是给它起个新名字
- [08:46] 就叫做Skew
- [08:48] 即Agent的技能
- [08:49] 好家伙
- [08:50] 这是网游戏里的英雄方向设计的
- [08:53] 好了
- [08:53] 现在这个Agent已经被你弄成这个鬼样子了
- [08:56] 你又发现对于一个复杂的任务
- [08:58] 可能Agent的上下文会变得非常大
- [09:01] 于是你又发明了个新概念叫SubAgent
- [09:04] 对于一些独立的子任务
- [09:05] 可以单独在这个ZAgent中完成
- [09:07] 其实本质上就是做了妈上下文隔离
- [09:10] ZAgent的产生的上下文不会保留在主Agent中
- [09:13] 仅此而已
- [09:14] 行了
- [09:15] 再好好看看你造的这些孽吧
- [09:18] 最后我想尝试高屋建领的梳理一下这些概念的关系
- [09:22] 这里的每一个新概念出来的时候
- [09:24] 都有大票的文章及其夸张的吹捧和营销
- [09:28] 但是在我看来
- [09:28] 这些概念的设计说的不好听点就是有点拉垮
- [09:32] 说的好听点就是技术发展的中间产物
- [09:35] 不过在这之前
- [09:36] 我们先看两个经典的容易混淆的问题
- [09:38] 在MCP刚出来的时候
- [09:40] 很多人问Function Calling和MCP有什么关系
- [09:43] 其实刚刚这张图就很清晰了
- [09:45] 一个是Agent和大模型沟通的约定
- [09:47] 目的是让大模型回答的符合一定的格式
- [09:50] 方便程序进行解析
- [09:52] 一个是Agent和工具服务之间调用的约定
- [09:55] 目的是像接口文档一样
- [09:56] 约定怎么调用
- [09:57] 怎么传参
- [09:58] 怎么接手返回值等等
- [10:00] 这俩完全不打岗
- [10:01] 甚至有人问是否MCP能够取代Function Calling
- [10:05] 这也是无机之谈
- [10:06] 在Skew刚出来的时候
- [10:08] 也有人问Skew和MCP有什么区别
- [10:10] Skew其实就是个Prompt加载器
- [10:13] 唯一需要的文件就是Skew.md
- [10:15] 其他的不做任何要求
- [10:16] 和MCP也不是一个唯独的东西
- [10:19] 不过Skew是否能取代MCP
- [10:21] 我认为是可以的
- [10:22] 因为你可以把MCP服务中提供的工具
- [10:25] 通通放在Skew的目录下
- [10:27] 并且在Skew.md文件中说明是如何使用的
- [10:30] 而且特别常用通用的小工具
- [10:32] 未来通通都会内化在Agent的主程序中
- [10:35] 所以目前看Skew稍稍有些积累
- [10:38] 不过拿Skew和MCP比本身也不大大
- [10:41] 不是一个层次上的事
- [10:42] 它其实更应该和这几个词做比较
- [10:45] 那我把这个顺序成为从刚性到柔性
- [10:48] 从稳定到变化
- [10:50] 它们的目标其实都是一个需要多个阶段才能完成的任务
- [10:54] 使用Lanchet就是纯编程的形式来实现
- [10:56] 全是硬编嘛
- [10:57] 虽然特别稳定
- [10:58] 但是也失去了一定的柔性
- [11:00] 很难包容一些小问题
- [11:02] 而Workflow只是把程序替换成的低代码的拖拽
- [11:05] 相对改起来的容易一些
- [11:07] Skew就是把Lanchet和Workflow这种
- [11:10] 由程序控制的流程走向
- [11:12] 变成了由智能体自行控制
- [11:14] 但是提前写好了一些双运文档和直接可运行的脚本
- [11:18] 存在一定灵活调整的空间
- [11:19] 同时又不至于变得特别不可控
- [11:22] 而最后的纯Agent的形式最为柔性
- [11:24] 因为它可以随时根据自己的判断进行调整流程
- [11:27] 甚至需要的时候自己给自己生成个脚本来运行
- [11:30] 但同时这也造成了容易变得不可控
- [11:32] 你不知道它中间会给自己写个什么脚本
- [11:35] 把一个原本非常简单的任务变得非常复杂
- [11:38] 所以这条线我认为是它们红管上的一个区别
- [11:41] 至于Skew的间谍式披露啊
- [11:43] 按区夹载啊
- [11:44] 我认为只是它的一个特性而已
- [11:45] 而这个特性也会在未来Token变得越来越便宜之后
- [11:48] 变得有点积累
- [11:50] 对于普通人来说
- [11:51] Skew兼顾了灵活性和稳定性
- [11:53] 我认为会逐渐淘汰掉MCP和Workflow
- [11:56] MCP就像刚刚说的
- [11:57] 常用的工具我认为会直接内化到Agent的主程序中
- [12:01] 或者在未来的基础Skew包中存在
- [12:03] 比较积累
- [12:04] 而Workflow这种既不如Lanchin一样适合程序员
- [12:07] 也不如Skew这样更适合我们普通人
- [12:10] 也属于一个比较积累的存在
- [12:12] 当然Skew我认为本身也是个中间产物
- [12:15] 未来一定会有更方便的形式出现
- [12:17] 让所有人都可以很符合直觉的无脑使用
- [12:20] 然后我想在从最本质的角度说这些技术
- [12:23] 其实所有的这些技术最终还是离不开大模型
- [12:26] 和我们之间的提示词
- [12:27] 这些技术无非就是帮助我们自动的往提示词里面增加商项文信息
- [12:32] 比如说search,rig,skew等等
- [12:35] 都是把一堆内容塞进了商项文
- [12:37] 或者通过代理的形式帮助我们减少和商项文沟通的次数
- [12:41] 为什么开头我说Agent是所有不需要智能的地方构成的部分呢
- [12:46] 就是说一个流程当中
- [12:47] 所有能用固定的程序来解决
- [12:49] 而不需要问大模型的地方
- [12:51] 就是Agent的发挥作用的地方
- [12:52] 其实就是把模糊的分流逻辑交给大模型
- [12:55] 根据语议识别处用户想做A还是B
- [12:58] 把确定的分流逻辑交给程序
- [13:00] 比如说PDF提取文本
- [13:02] 最终的目标都是节省人力的时间
- [13:04] 降低人力的使用门槛罢了
- [13:07] 但是现在还有我最大的问题就是token实在是太贵了
- [13:10] 越是强大的自己能默默处理问题的Agent
- [13:13] 背后消耗的token就越大
- [13:15] 但我觉得这在未来或许不是问题
- [13:17] 因为token一定会越来越便宜
- [13:19] 甚至等到什么时候一个生产级别的大模型
- [13:22] 可以轻松部署在一台普普通通的电脑上的时候
- [13:25] token就相当于免费了
- [13:27] 由此我又想到了扎袜领域的spring boot和pacen领域的UV
- [13:31] 你会发现这两者都是将开发者的便利完全放在第一位
- [13:35] 什么运行速度快不快 包得体积大不大
- [13:37] 是不是浪费魅存空间或者磁板空间
- [13:40] 这些问题最终和使用的便利性相比
- [13:42] 几乎都是瞬间被秒杀了
- [13:44] 重学上学这么怕麻烦
- [13:46] 而在Agent的领域我认为更是如此
- [13:48] 因为它面向的是普通人
- [13:50] 不可能让普通人去把什么sql放到指定的目楼下
- [13:53] 去配置什么msp服务甚至配置哪个大模型的API key
- [13:57] 这些都会被一个极为便利的产品淘汰掉
- [14:00] 比如最近的cloud bolt为什么这么火
- [14:02] 除了一些营销因素以外
- [14:04] 难道它和cloud code codex mantis这些Agent有什么本质区别吗
- [14:08] 完全没有
- [14:09] 就只是因为它能连接社交软件
- [14:11] 能够配置定时任务
- [14:13] 有个页面能看到sql并管理它们
- [14:15] 第一次让普通人觉得它像一个智能体
- [14:17] 而不只是躺在电脑上的一个服务了
- [14:20] 那未来究竟会是什么样呢
- [14:22] 我认为只要是提供便利的方向就是趋势
- [14:25] 比如未来我认为一定有个打包好的超级Agent
- [14:28] 配置好了所有常用的msp sql等等乱七八糟的东西
- [14:32] 甚至已经不叫这个名字了
- [14:33] 普通人啥都不用配置也能直接使用起来
- [14:36] 好了本期视频就到这里
- [14:38] 看在这么长的份上能不能给我个三年呀
