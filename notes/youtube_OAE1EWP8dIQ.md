# YouTube 影片摘要

**影片連結**: https://youtu.be/OAE1EWP8dIQ?si=r2Cg9AxTcXUg0DbG

**影片 ID**: OAE1EWP8dIQ

**處理日期**: 2026-02-10 10:25

**影片類型**: 教程/教學類影片

---

## 影片主題
AI-ZENTA：一個用於與AI模型交互的工具，透過文件管理和系統提示來協同工作。

## 📋 章節與時間戳
- [00:00] 影片開場與AI-ZENTA介紹 (簡述其功能)
- [02:30] 核心概念：AI-ZENTA的角色 - 橋樑，將用戶需求轉化為AI模型指令
- [05:00] 文件管理韓數：Read file、List file、Rename file 等的介紹與重要性
- [08:30] 韓數命名與參數設計：重要性，明確Docstring
- [11:00] Docstring 與AI模型互動：利用Docstring告知模型韓數功能和返回值
- [13:00] 探索其他模型：Google Gemini，排單體格AI支持的通用性
- [17:00] Gemeline 模型的 API key 管理：安全儲存 (環境變數、.env 文件)
- [20:00] Agent 建立與 System Prompt 設定：定義AI角色
- [23:00] Agent 的核心功能 - 韓數調用與用戶指令處理
- [27:00] 測試程序演示：列出文件、讀取文件內容、語言識別
- [31:00] 解決上下文問題：透過Message History保留對話記錄，讓AI記住之前的內容
- [35:00] 檔案重命名測試：利用Agent的功能完成檔案重命名
- [38:00] 影片結尾

## 📖 內容重點
1. **AI-ZENTA 概述：**
    *   小程序，用於連接用戶、AI模型和各種功能韓數。
    *   核心機制：將用戶需求轉換為 AI 模型可理解的指令。
    *   利用系統提示（System Prompt）和代碼執行（Coding）的方式與模型互動。

2. **文件管理韓數：**
    *   `Read file`：讀取文件內容。
    *   `List file`：列出文件目錄。
    *   `Rename file`：重命名文件。
    *   這些韓數與AI模型無直接關係，但提供了文件操作的基礎。

3. **韓數設計原則：**
    *   **清晰的韓數名和參數名：**  易於理解，說明韓數功能。
    *   **明確的返回值和參數類型標註：**  AI模型可以通過類型資訊了解韓數功能，提高穩定性。
    *   **Docstring 的使用：**  向AI模型解釋韓數的功能、參數、返回值，即使韓數名不夠清晰。

4. **Context Management (上下文管理)：**
    *   AI模型在每次調用Agent時，默認不記住之前的對話內容和韓數調用紀錄。
    *   解決方案：透過保存完整的對話紀錄 (Message History) 傳遞給Agent，讓Agent記住之前的內容，避免重複操作。

5. **Agent 架構：**
    *   Agent：負責與AI模型和工具韓數進行交互。
    *   包含：Gemeline模型，System Prompt (定義AI角色)，工具韓數 (如Read file, List file, Rename file)。

## 💡 實用技巧/命令
- **Docstring 的設計:** 確保Docstring清晰說明韓數的功能、參數、返回值，方便AI模型理解。
- **Context Management:**  透過Message History儲存對話記錄，讓AI模型記住上下文，避免重複操作。
- **API Key 安全儲存:**  使用環境變數或 `.env` 檔案儲存API Key，避免硬編碼。
- **選擇模型:** 根據需求選擇合适的模型，排單體格AI模型幾乎支持所有的模型。

## 🔑 關鍵概念
- **System Prompt:**  AI模型的角色定義，影響模型的回應方式。
- **Agent:**  協同作業的橋樑，負責與AI模型和工具韓數交互。
- **Message History:**  對話紀錄，用於解決上下文問題。
- **API (Application Programming Interface):**  應用程式介面，允許不同的軟體系統互相通訊和交換數據。
- **Prompt Engineering:**設計有效的Prompt，以獲得期望的AI模型回覆。


---

## 📋 章節與時間戳

- [00:00] AI-ZENTA是一個小程序,它負責在用戶,AI-模型和功能韓數之間進行傳話
- [00:06] 比如說,我們想讓AI幫忙管理本地文件,但模型本身是沒辦法直接讀取硬盤的
- [00:14] 所以我們需要寫好一系列的文件管理韓數
- [00:18] 再把這些韓數駐測到AI-ZENTA裡面
- [00:21] AI-ZENTA就會把這些韓數的信息通過System Prompt或者方式Coding的方式告訴AI-模型
- [00:29] 於是模型就可以返回指令引導A-ZENTA掉用相應的韓數去完成用戶的請求了
- [00:36] 如果你還想了解更多關於A-ZENTA Trumppt,方聲Coding甚至MCP的內容
- [00:42] 可以看這期視頻的完整講解十分鐘帶你理清他們之間的關係
- [00:47] 現在我們回到代碼,今天我們要開發的是一個簡單AI-ZENTA
- [00:53] 它負責管理Test文件加下的這些ABCD文件
- [00:58] 這些文件都是一些勢力代碼有的是用Python寫的
- [01:02] 有的是用C語安寫的
- [01:05] 還有的用的是GO
- [01:07] 為了讓AI-模型能看得見這些文件我們需要提供幾個本地韓數
- [01:13] 我已經預先寫好了三個韓數
- [01:16] Read file負責讀文件
- [01:18] Lisa files負責列目錄
- [01:21] 還有Rename file負責改文件名
- [01:26] 他們都是很普通的文件操作的代碼和AI沒有直接關係
- [01:30] 這裡我就不展開了
- [01:32] 但是有幾點需要注意首先是韓數名
- [01:36] 以及參數名一定要寫的清洗
- [01:39] 最好一看就知道是幹什麼的
- [01:41] 然後返回值和參數類型
- [01:44] 也要加上明確的類型標註
- [01:47] 因為AI-模型就是通過這些信息了解韓數功能的
- [01:51] 但是如果韓數比較負責
- [01:53] 廣告名字說不清楚的時候怎麼辦呢
- [01:56] 這個時候我們可以寫DocString
- [01:58] DocString的內容也會被AI模型看到
- [02:01] 比如說我可以用Read file的DocString告訴AI
- [02:04] 如果文件不存在韓數就會返回錯誤提示
- [02:15] 總之我們就把AI當成一個程序員
- [02:18] 我們的任務就是給它提供 API和 API的文檔
- [02:21] 因為這裡的韓數都非常的簡單
- [02:23] 剩下的DocString我就不寫了
- [02:25] 接下來我們開始寫Agent
- [02:28] 今天我們要用到的庫是排單體格AI
- [02:31] 模型用的是Google的Gemeline
- [02:33] 但是排單體格AI幾乎支持所有的模型
- [02:36] 你可以參考官方文檔選擇不同的接口
- [02:39] 連接我會放在視頻簡介中
- [02:42] 首先我們先創建一個代表Gemeline模型的Gemeline module實力
- [02:49] 模型的API key我不建議直接寫在代碼裡面
- [02:51] 因為太不安全了
- [02:52] 一般情況下我們可以放到環境變亮裡面
- [02:54] 比如對於Gemeline模型來講
- [02:56] 我們就要把Key放到一個叫做Gemeline API key的變亮裡面
- [03:04] 但是如果我們每次都要手動更改環境變亮
- [03:07] 也挺麻煩的
- [03:08] 所以更長的
- [03:10] 所以我們就要把Key的變亮
- [03:12] 但是如果我們每次都要手動更改環境變亮
- [03:15] 也挺麻煩的
- [03:16] 所以更長件的做法
- [03:18] 是把它寫到一個叫做點E-N-V的文件裡面
- [03:22] 然後我們可以用Python.inv的Low的韓數進行加載
- [03:35] 它的作用和我們直接把Key寫到環境變亮中是一樣的
- [03:39] 不過注意提交代碼的時候
- [03:41] 不要把點E-N-V文件也一起提交到Git上
- [03:46] 這樣我們的模型就準備好了
- [03:48] 接下來我們生成一個Agent對象
- [03:50] 負責和模型用戶韓數進行通信
- [04:03] 我們剛剛創建的模型Model是Agent的第一個參數
- [04:09] 除了模型本身
- [04:13] 我們還需要傳入一個System Prompt來定義AI的角色信息
- [04:18] 比如說這裡我設定它是一個經驗豐富的程序園
- [04:32] 最後我們通過兔參數
- [04:34] 把剛剛展示過的READFILM這些工具韓數駐測在Agent中
- [04:58] 寫到這裡我們的模型
- [05:01] Agent
- [05:02] 和工具韓數就都已經準備好了
- [05:05] 接下來我們來一些主程序
- [05:08] 這裡我們直接通過標準輸入來接受用戶的指令
- [05:22] 然後我們把用戶的輸入通過RUNSync韓數直接傳給Agent
- [05:33] 這樣Agent就會自動根據用戶的需求和AI的反回結果
- [05:39] 來調用韓數並完成用戶的指令
- [05:42] 最後我們把AI的最終反回結果也打印出來
- [05:50] 這樣的程序基本上就寫完了我們來測試一下
- [05:58] 比如說我讓它列出ABCD EF
- [06:01] 這些文件使用的語言我們就可以這樣寫
- [06:16] 可以看到AI模型決定先調用List file
- [06:20] 把所有的文件都列出來
- [06:22] 然後一個一個的調用READFILM去讀取他們的內容
- [06:27] 最後根據內容再告訴我們每個文件
- [06:30] 大概是用什麼語言寫的
- [06:33] 但是這裡有一個問題比如說我接著問它避文件的功能是什麼
- [06:46] 可以看到AI模型雖然也回大了出來
- [06:49] 但是它又去讀了一次避文件
- [06:52] 但是它明明在剛才的那次對話之中
- [06:55] 已經讀過避文件了
- [06:57] 怎麼還要重新再讀一遍呢
- [06:59] 這個是因為當我們每次調用Agent RUN性感韓數的時候
- [07:03] 默認他們之間是相互努力的
- [07:07] Agent是不會自動記住你上一次說過什麼的
- [07:11] 也不知道它剛剛讀過哪些文件
- [07:14] 所以如果我們想讓Agent記住上下文
- [07:17] 我們還得自己保留一下聊天記錄
- [07:19] 其實也非常簡單
- [07:21] 因為在每次調用完Agent RUN性感韓數之後
- [07:25] 我們都能拿到一份完整的對話記錄
- [07:28] 這裡我們就把它考卑一份
- [07:35] 然後下次發送消息的時候
- [07:37] 我們把這段歷史記錄通過Message History傳說傳遞進去
- [07:49] 由於有了上下文
- [07:50] AI就可以記住我們之前都說了什麼
- [07:53] 之前讀過的文件幣
- [07:55] 也就不需要再重新讀一遍了
- [07:57] 我們再來測試一下程序
- [08:05] 我們還是先讓它識別每個文件使用的語言
- [08:20] 好這一次我們讓它根據文件的內容
- [08:23] 來給文件進行改名
- [08:25] 我們可以這樣寫
- [08:35] 可以看到這一次AI就沒有再次讀取文件的內容
- [08:38] 而是直接調用了RUNEMHANSHO
- [08:41] 給每個文件都加上了它們自己的擴展名
- [08:44] 我們再去看一下太層目錄
- [08:48] 可以看到文件名也都被正確地改了過來
- [08:51] 這就是一個最基礎的AIAgent架構了
- [08:54] 邏輯並不複雜
- [08:56] 但背後的機制卻很有意思
- [08:58] 希望這個視頻能幫你更清楚的理解整個流程
- [09:02] 這裡是程旋老王我們下期再見

---

## 📖 完整轉錄內容

AI-ZENTA是一個小程序,它負責在用戶,AI-模型和功能韓數之間進行傳話比如說,我們想讓AI幫忙管理本地文件,但模型本身是沒辦法直接讀取硬盤的所以我們需要寫好一系列的文件管理韓數再把這些韓數駐測到AI-ZENTA裡面AI-ZENTA就會把這些韓數的信息通過System Prompt或者方式Coding的方式告訴AI-模型於是模型就可以返回指令引導A-ZENTA掉用相應的韓數去完成用戶的請求了如果你還想了解更多關於A-ZENTA Trumppt,方聲Coding甚至MCP的內容可以看這期視頻的完整講解十分鐘帶你理清他們之間的關係現在我們回到代碼,今天我們要開發的是一個簡單AI-ZENTA它負責管理Test文件加下的這些ABCD文件這些文件都是一些勢力代碼有的是用Python寫的有的是用C語安寫的還有的用的是GO為了讓AI-模型能看得見這些文件我們需要提供幾個本地韓數我已經預先寫好了三個韓數Read file負責讀文件Lisa files負責列目錄還有Rename file負責改文件名他們都是很普通的文件操作的代碼和AI沒有直接關係這裡我就不展開了但是有幾點需要注意首先是韓數名以及參數名一定要寫的清洗最好一看就知道是幹什麼的然後返回值和參數類型也要加上明確的類型標註因為AI-模型就是通過這些信息了解韓數功能的但是如果韓數比較負責廣告名字說不清楚的時候怎麼辦呢這個時候我們可以寫DocStringDocString的內容也會被AI模型看到比如說我可以用Read file的DocString告訴AI如果文件不存在韓數就會返回錯誤提示總之我們就把AI當成一個程序員我們的任務就是給它提供 API和 API的文檔因為這裡的韓數都非常的簡單剩下的DocString我就不寫了接下來我們開始寫Agent今天我們要用到的庫是排單體格AI模型用的是Google的Gemeline但是排單體格AI幾乎支持所有的模型你可以參考官方文檔選擇不同的接口連接我會放在視頻簡介中首先我們先創建一個代表Gemeline模型的Gemeline module實力模型的API key我不建議直接寫在代碼裡面因為太不安全了一般情況下我們可以放到環境變亮裡面比如對於Gemeline模型來講我們就要把Key放到一個叫做Gemeline API key的變亮裡面但是如果我們每次都要手動更改環境變亮也挺麻煩的所以更長的所以我們就要把Key的變亮但是如果我們每次都要手動更改環境變亮也挺麻煩的所以更長件的做法是把它寫到一個叫做點E-N-V的文件裡面然後我們可以用Python.inv的Low的韓數進行加載它的作用和我們直接把Key寫到環境變亮中是一樣的不過注意提交代碼的時候不要把點E-N-V文件也一起提交到Git上這樣我們的模型就準備好了接下來我們生成一個Agent對象負責和模型用戶韓數進行通信我們剛剛創建的模型Model是Agent的第一個參數除了模型本身我們還需要傳入一個System Prompt來定義AI的角色信息比如說這裡我設定它是一個經驗豐富的程序園最後我們通過兔參數把剛剛展示過的READFILM這些工具韓數駐測在Agent中寫到這裡我們的模型Agent和工具韓數就都已經準備好了接下來我們來一些主程序這裡我們直接通過標準輸入來接受用戶的指令然後我們把用戶的輸入通過RUNSync韓數直接傳給Agent這樣Agent就會自動根據用戶的需求和AI的反回結果來調用韓數並完成用戶的指令最後我們把AI的最終反回結果也打印出來這樣的程序基本上就寫完了我們來測試一下比如說我讓它列出ABCD EF這些文件使用的語言我們就可以這樣寫可以看到AI模型決定先調用List file把所有的文件都列出來然後一個一個的調用READFILM去讀取他們的內容最後根據內容再告訴我們每個文件大概是用什麼語言寫的但是這裡有一個問題比如說我接著問它避文件的功能是什麼可以看到AI模型雖然也回大了出來但是它又去讀了一次避文件但是它明明在剛才的那次對話之中已經讀過避文件了怎麼還要重新再讀一遍呢這個是因為當我們每次調用Agent RUN性感韓數的時候默認他們之間是相互努力的Agent是不會自動記住你上一次說過什麼的也不知道它剛剛讀過哪些文件所以如果我們想讓Agent記住上下文我們還得自己保留一下聊天記錄其實也非常簡單因為在每次調用完Agent RUN性感韓數之後我們都能拿到一份完整的對話記錄這裡我們就把它考卑一份然後下次發送消息的時候我們把這段歷史記錄通過Message History傳說傳遞進去由於有了上下文AI就可以記住我們之前都說了什麼之前讀過的文件幣也就不需要再重新讀一遍了我們再來測試一下程序我們還是先讓它識別每個文件使用的語言好這一次我們讓它根據文件的內容來給文件進行改名我們可以這樣寫可以看到這一次AI就沒有再次讀取文件的內容而是直接調用了RUNEMHANSHO給每個文件都加上了它們自己的擴展名我們再去看一下太層目錄可以看到文件名也都被正確地改了過來這就是一個最基礎的AIAgent架構了邏輯並不複雜但背後的機制卻很有意思希望這個視頻能幫你更清楚的理解整個流程這裡是程旋老王我們下期再見

---

*由 OpenClaw youtube-summary 生成*
